/// <reference types="node" />
declare type OpenSSLHandle = {};
declare type KeccakHandle = {};
declare enum OpenSSLHashType {
    OPENSSL_MD5 = 0,
    OPENSSL_MD4 = 1,
    OPENSSL_SHA1 = 2,
    OPENSSL_SHA224 = 3,
    OPENSSL_SHA256 = 4,
    OPENSSL_SHA384 = 5,
    OPENSSL_SHA512 = 6
}
declare enum KeccakHashType {
    KECCAK_224 = 0,
    KECCAK_256 = 1,
    KECCAK_384 = 2,
    KECCAK_512 = 3,
    SHA3_224 = 4,
    SHA3_256 = 5,
    SHA3_384 = 6,
    SHA3_512 = 7
}
declare enum XxHashType {
    xxHash64 = 0,
    xxHash32 = 1
}
export interface Hash {
    digest(output?: OutputType): Buffer | string | bigint;
    digestBigInt(): bigint;
    update(data: string | Buffer, inputEncoding?: InputEncoding): Hash;
}
/**
 * Represents a string that can be passed to request a supported hashing
 * algorithm.
 */
export declare enum HashType {
    /**
     * MD5, 128-bit digest as specified in RFC 1321. "Cryptographically broken
     * and unsuitable for further use."
     */
    MD5 = "md5",
    /** SHA-1, a 160-bit digest. No longer considered secure. */
    SHA1 = "sha1",
    /** SHA-224, a 224-bit digest from the SHA-2 family. */
    SHA224 = "sha224",
    /** SHA-256, a 256-bit digest from the SHA-2 family. */
    SHA256 = "sha256",
    /** SHA-384, a 384-bit digest from the SHA-2 family. */
    SHA384 = "sha384",
    /** SHA-512, a 512-bit digest from the SHA-2 family. */
    SHA512 = "sha512",
    /**
     * SHA3-224, a 224-bit digest using the Keccak family, with 0x6 used for
     * padding.
     */
    SHA3_224 = "sha3-224",
    /**
     * SHA3-256, a 256-bit digest using the Keccak family, with 0x6 used for
     * padding.
     */
    SHA3_256 = "sha3-256",
    /**
     * SHA3-384, a 384-bit digest using the Keccak family, with 0x6 used for
     * padding.
     */
    SHA3_384 = "sha3-384",
    /**
     * SHA3-512, a 512-bit digest using the Keccak family, with 0x6 used for
     * padding.
     */
    SHA3_512 = "sha3-512",
    /**
     * Keccak224, a 224-bit digest using the Keccak family, with 0x0 used for
     * padding.
     */
    KECCAK224 = "keccak224",
    /**
     * Keccak256, a 256-bit digest using the Keccak family, with 0x0 used for
     * padding. Commonly used for Ethereum.
     */
    KECCAK256 = "keccak256",
    /**
     * Keccak384, a 384-bit digest using the Keccak family, with 0x0 used for
     * padding.
     */
    KECCAK384 = "keccak384",
    /**
     * Keccak512, a 512-bit digest using the Keccak family, with 0x0 used for
     * padding.
     */
    KECCAK512 = "keccak512",
    /**
     * xxHash64, a extremely fast non-cryptographic hash algorithm with a 64-bit
     * digest.
     */
    xxHash64 = "xxHash64",
    /**
     * xxHash32, a extremely fast non-cryptographic hash algorithm with a 32-bit
     * digest.
     */
    xxHash32 = "xxHash32"
}
/** Reperesents the types of input encoding which may be used by a string. */
export declare enum InputEncoding {
    /** UTF-8, the default encoding */
    UTF8 = "utf8",
    /** ASCII, without UTF-8 extensions. */
    ASCII = "ascii",
    /** Latin 1, as specified in ISO-8859-1 */
    LATIN1 = "latin1"
}
/** Reperesents the permitted set of output types for a digest. */
export declare enum OutputType {
    /** Output a bigint digest. */
    BigInt = "bigint",
    /** Output a buffer digest. */
    Buffer = "buffer"
}
/** An internal hasher which calls OpenSSL. Do not use directly. */
export declare class OpensslHasher implements Hash {
    private opensslType;
    private opensslHandle;
    private disposed;
    static getOpensslType(hash: HashType): OpenSSLHashType;
    constructor(hash: HashType, opensslType?: OpenSSLHashType, opensslHandle?: OpenSSLHandle);
    digest(output?: OutputType): bigint | Buffer;
    digestBigInt(): bigint;
    update(data: string | Buffer, inputEncoding?: InputEncoding): Hash;
}
/**
 * An internal hasher which calls the eXtended Keccak Code Package. Do not use
 * directly.
 */
export declare class KeccakHasher implements Hash {
    private keccakType;
    private keccakHandle;
    private disposed;
    static getKeccakType(hash: HashType): KeccakHashType;
    constructor(hash: HashType, keccakType?: KeccakHashType, keccakHandle?: KeccakHandle);
    digest(output?: OutputType): bigint | Buffer;
    digestBigInt(): bigint;
    update(data: string | Buffer, inputEncoding?: InputEncoding): Hash;
}
/**
 * An internal hasher which calls xxHash. Do not use
 * directly.
 */
export declare class XxHasher implements Hash {
    private xxType;
    private xxHandle;
    private disposed;
    static getXxHashType(hash: HashType): XxHashType;
    constructor(hash: HashType, xxType?: XxHashType, xxHandle?: any);
    digest(output?: OutputType): bigint | Buffer;
    digestBigInt(): bigint;
    update(data: string | Buffer, inputEncoding?: InputEncoding): Hash;
}
/**
 * Obtain a hasher instance for hashing. If you will only hash a single buffer,
 *  call the [[hashAsBigInt]] or [[hashAsBuffer]] functions instead, as they
 *  yield better performance.
 *
 *  @param hash The type of algorithm to support
 *
 *  @returns A [[Hash]] instance for hashing.
 */
export declare function getHasher(hash: HashType): Hash;
/**
 * Hash the given buffer using the hashing algorithm specified, returning
 *  the digest as a bigint.
 *
 *  @param hash The hash algorithm to use.
 *  @param buf  The buffer to use.
 *
 *  @returns A bigint with the message digest.
 */
export declare function hashAsBigInt(hash: HashType, buf: Buffer): bigint;
/**
 * Hash the given buffer using the hashing algorithm specified, returning
 *  the digest as a Buffer.
 *
 *  @param hash The hash algorithm to use.
 *  @param buf  The buffer to use.
 *
 *  @returns A buffer with the message digest.
 */
export declare function hashAsBuffer(hash: HashType, buf: Buffer): Buffer;
export {};
